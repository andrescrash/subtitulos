<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css?family=M+PLUS+1p" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=M+PLUS+Rounded+1c" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Hachi+Maru+Pop" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Yusei+Magic" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Reggae+One" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Sawarabi+Gothic" rel="stylesheet">
    <link href="https://fonts.googleapis.com/earlyaccess/nicomoji.css" rel="stylesheet">

    <link href="./font.css" rel="stylesheet">

    <link rel="icon" href="./img/favicon2/favicon.ico" />
    <script src="js/bouyomichan_client.js"></script>
    <script src="chrome_translator_v2.js"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FKQVD3TMXH"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FKQVD3TMXH');
    </script>
    <!-- FIN: Google tag (gtag.js) -->


    <title>Subtítulos en Vivo — Pantalla</title>

    <style type="text/css">
        button, input, select, textarea {
            font-weight : 0;
            vertical-align : top;
            -webkit-text-stroke-color: rgb(21, 0, 141);
            -webkit-text-stroke-width: 0px;
        }

        html {
            height: 100%;
            width: 100%;
        }

        body {
            height: 100%;
            width: 100%;
            margin: 0;
            overflow:hidden;
            font-family: 'M PLUS Rounded 1c', sans-serif;
        }
        table {
            width: 100%;
            overflow:hidden;
        }
        table.btm_table {
            position:absolute;
        }

        table td {
            overflow-wrap : break-word;
        }
    </style>

    <style>
        /* Estado de descarga del modelo ChromeTraducción */
        #downloadStatus {
            position: fixed;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000;
            display: none;
            animation: pulse 2s infinite;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        #downloadStatus.downloading {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #856404;
        }
        
        #downloadStatus.completed {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: #155724;
        }
    </style>

    <style>
        /* preparar los selectores para agregar borde */

        .stroke-single-imb{
            left: 0;
            right: 0;
            margin: 0;
            margin-left: 5px;
        }

        .stroke-single-bg{
            position: absolute;
            left: 0;
            right: 0;
            margin: auto;
            margin-left: 5px;
        }

        .stroke-single-fg{
            position: absolute;
            left: 0;
            right: 0;
            margin: auto;
            margin-left: 5px;
        }

    </style>

    <script>

        // Función para obtener parámetros URL ---------------------------
        function getParam(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&]*)|&|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        // Eliminar texto si no hay cambios por un tiempo ------------------------------------
        var fn_del = function() {
            document.getElementById('speech_text-imb').innerHTML = '';
            document.getElementById('speech_text-bg').innerHTML = '';
            document.getElementById('speech_text-fg').innerHTML = '';
            document.getElementById('trans_text-imb').innerHTML = '';
            document.getElementById('trans_text-bg').innerHTML = '';
            document.getElementById('trans_text-fg').innerHTML = '';
            document.getElementById('trans_text2-imb').innerHTML = '';
            document.getElementById('trans_text2-bg').innerHTML = '';
            document.getElementById('trans_text2-fg').innerHTML = '';
            document.getElementById('trans_text3-imb').innerHTML = '';
            document.getElementById('trans_text3-bg').innerHTML = '';
            document.getElementById('trans_text3-fg').innerHTML = '';

            // Reiniciar todas las banderas
            isSpeechRecognitionComplete = false;
            isTextTranslation1Complete = false;
            isTextTranslation2Complete = false;
            isTextTranslation3Complete = false;
            
            // Limpiar texto temporal también
            currentInterimText = '';
            lastFinalText = '';
        };


        // Leer valores desde URL (temporizador de eliminación) -------------------
        var timer = getParam('timer');
        
        // Si no hay resultados de reconocimiento por un tiempo, finalizar reconocimiento --------------------
        var short_pause = getParam('short_pause');
        
        // Para depuración: Verificar configuración del temporizador
        console.log('Configuración del temporizador:', {
            timer: timer + 'ms (eliminación de texto)',
            short_pause: short_pause + 'ms (detección de pausa de voz)'
        });

        //////////////////////////////////////////////////////////
        // Leer valores desde URL -------------------
        var arg_showAudioLevel = getParam('showAudioLevel');
        var arg_enhanceAccuracy = getParam('enhanceAccuracy');
        var arg_noiseReduction = getParam('noiseReduction');
        var arg_volumeNormalization = getParam('volumeNormalization');
        var arg_showConfidence = getParam('showConfidence');
        var arg_useCustomDictionary = getParam('useCustomDictionary');
        var arg_customDictionary = getParam('customDictionary');
        var arg_recog = getParam('recog');
        console.log('Parámetro de lenguaje de reconocimiento de voz:', arg_recog);
        var arg_trans = getParam('trans');
        var arg_trans2 = getParam('trans2');
        var arg_trans3 = getParam('trans3');

        /////////////////////////////////////////////////////////
        // Configuración para API de Traducción ---------------------------
        if (arg_trans != null) var request = new XMLHttpRequest();
        if (arg_trans2 != null) var request2 = new XMLHttpRequest();
        if (arg_trans3 != null) var request3 = new XMLHttpRequest();

        // Configuración de Traducción ---------------------------
        var trans_sourcelang = 'ja';
        var trans_destlang = 'en';
        var trans2_destlang = '';
        var trans3_destlang = '';


        var gas_key = getParam('gas_key');
        
        var TRANS_URL = 'https://script.google.com/macros/s/' + gas_key + '/exec';
        var query = ''

        // Otras configuraciones -----------------------
        var bouyomi = getParam('bouyomi');
        var anti_sexual = getParam('anti_sexual');
        
        // Preparar diccionario personalizado
        var customDictionary = {};
        if (arg_useCustomDictionary === 'true' && arg_customDictionary) {
            try {
                const dictionaryText = decodeURIComponent(arg_customDictionary);
                const entries = dictionaryText.split('、').concat(dictionaryText.split(','));
                entries.forEach(entry => {
                    const parts = entry.split('=');
                    if (parts.length === 2) {
                        customDictionary[parts[0].trim()] = parts[1].trim();
                    }
                });
                console.log('Diccionario personalizado cargado:', Object.keys(customDictionary).length + ' entradas');
            } catch (error) {
                console.error('Error al analizar el diccionario personalizado:', error);
            }
        }
        
        // Función de preprocesamiento de traducción (aplicar diccionario personalizado)
        function applyCustomDictionary(text) {
            if (arg_useCustomDictionary !== 'true' || Object.keys(customDictionary).length === 0) {
                return text;
            }
            
            let processedText = text;
            for (const [key, value] of Object.entries(customDictionary)) {
                const regex = new RegExp('\\b' + key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                processedText = processedText.replace(regex, value);
            }
            return processedText;
        }

        // Función de filtrado de contenido inapropiado (para reconocimiento)
        function applyContentFilter(text) {
            if (anti_sexual === 'false' || badWords_forRecog.length === 0) {
                return text;
            }
            
            let filteredText = text;
            
            // Reemplazar palabras protegidas con marcadores temporales
            goodWords_forRecog.forEach((word, index) => {
                if (word && word.trim() !== '') {
                    let placeholder = `{{GOOD_WORD_${index}}}`;
                    const regex = new RegExp(word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "gi");
                    filteredText = filteredText.replace(regex, placeholder);
                }
            });

            // Reemplazar palabras inapropiadas con ***
            badWords_forRecog.forEach(word => {
                if (word && word.trim() !== '') {
                    const regex = new RegExp(word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "gi");
                    filteredText = filteredText.replace(regex, "*".repeat(word.length));
                }
            });

            // Restaurar palabras protegidas desde marcadores temporales
            goodWords_forRecog.forEach((word, index) => {
                if (word && word.trim() !== '') {
                    let placeholder = `{{GOOD_WORD_${index}}}`;
                    const regex = new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "g");
                    filteredText = filteredText.replace(regex, word);
                }
            });

            return filteredText;
        }

        // Función de filtrado para resultados de traducción
        function applyTranslationFilter(text, transType) {
            if (anti_sexual === 'false' || !text || text.trim() === '') {
                return text;
            }
            
            let badWordsList, goodWordsList;
            
            // Seleccionar lista de palabras inapropiadas según el tipo de traducción
            switch(transType) {
                case 1:
                    badWordsList = badWords_forTrans1;
                    goodWordsList = goodWords_forTrans1;
                    break;
                case 2:
                    badWordsList = badWords_forTrans2;
                    goodWordsList = goodWords_forTrans2;
                    break;
                case 3:
                    badWordsList = badWords_forTrans3;
                    goodWordsList = goodWords_forTrans3;
                    break;
                default:
                    return text;
            }
            
            if (badWordsList.length === 0) {
                console.log('Lista de palabras inapropiadas para traducción' + transType + ' vacía, omitiendo filtrado');
                return text;
            }
            
            let filteredText = text;
            
            // Reemplazar palabras protegidas con marcadores temporales
            goodWordsList.forEach((word, index) => {
                if (word && word.trim() !== '') {
                    let placeholder = `{{TRANS${transType}_GOOD_WORD_${index}}}`;
                    const regex = new RegExp(word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "gi");
                    filteredText = filteredText.replace(regex, placeholder);
                }
            });

            // Reemplazar palabras inapropiadas con ***
            badWordsList.forEach(word => {
                if (word && word.trim() !== '') {
                    const regex = new RegExp(word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "gi");
                    filteredText = filteredText.replace(regex, "*".repeat(word.length));
                }
            });

            // Restaurar palabras protegidas desde marcadores temporales
            goodWordsList.forEach((word, index) => {
                if (word && word.trim() !== '') {
                    let placeholder = `{{TRANS${transType}_GOOD_WORD_${index}}}`;
                    const regex = new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "g");
                    filteredText = filteredText.replace(regex, word);
                }
            });

            console.log('Filtrado de traducción' + transType + ': "' + text + '" -> "' + filteredText + '"');
            return filteredText;
        }


        // Si no hay resultados de reconocimiento por un tiempo, finalizar reconocimiento --------------------
        // short_pause ya está definido arriba

        var stop_recog;
        var id_stop_recog;

        var count = 0;

        // Cargar listas de palabras Bad/Good desde URL en formato de lista -----------------------
        // Mapeo de códigos de lenguaje con guión para rutas de archivo
        function getFilterLanguageId(langCode) {
            const languageMapping = {
                'zh-CN': 'zh',     // Chino simplificado
                'zh-TW': 'zh',     // Taiwanés (tradicional) → Usar filtro chino
                'zh-HK': 'zh',     // Hongkonés (tradicional) → Usar filtro chino
                'en-US': 'en',     // Inglés americano → Usar filtro inglés
                'fr-FR': 'fr',     // Francés
                'it-IT': 'it',     // Italiano
                'de-DE': 'de',     // Alemán
                'tr-TR': 'tr',     // Turco
                'sv-SE': 'sv',     // Sueco
                'pl-PL': 'pl',     // Polaco
                'uk-UA': 'uk',     // Ucraniano
                'ru-RU': 'ru',     // Ruso
                'es-ES': 'es',     // Español
                'pt-PT': 'pt',     // Portugués
                'th-TH': 'th',     // Tailandés
                'el-GR': 'el'      // Griego
            };
            
            return languageMapping[langCode] || langCode;
        }
        
        // Mapeo de códigos de lenguaje para API de Traducción
        function getTranslationLanguageId(langCode) {
            const languageMapping = {
                'zh-CN': 'zh-CN',  // Chino simplificado
                'zh-TW': 'zh-TW',  // Taiwanés (tradicional)
                'zh-HK': 'zh-HK',  // Hongkonés (tradicional)
                'en-US': 'en',     // Inglés americano
                'fr-FR': 'fr',     // Francés
                'it-IT': 'it',     // Italiano
                'de-DE': 'de',     // Alemán
                'tr-TR': 'tr',     // Turco
                'sv-SE': 'sv',     // Sueco
                'pl-PL': 'pl',     // Polaco
                'uk-UA': 'uk',     // Ucraniano
                'ru-RU': 'ru',     // Ruso
                'es-ES': 'es',     // Español
                'pt-PT': 'pt',     // Portugués
                'nl-NL': 'nl',     // Holandés
                'id-ID': 'id',     // Indonesio
                'vi-VN': 'vi',     // Vietnamita
                'th-TH': 'th',     // Tailandés
                'ar-SA': 'ar',     // Árabe
                'el-GR': 'el',     // Griego
                'ja': 'ja',        // Japonés
                'ko': 'ko'         // Coreano
            };
            
            return languageMapping[langCode] || langCode;
        }
        
        let languageId = getFilterLanguageId(arg_recog);
        const baseURL = "https://raw.githubusercontent.com/sayonari/goodBadWordlist/main/";
        const badListPath = `/BadList.txt`; // Ruta de lista de palabras prohibidas
        const goodListPath = `/GoodList.txt`; // Ruta de lista de palabras permitidas
        var badWords_forRecog = [];
        var goodWords_forRecog = [];
        
        // Listas de palabras inapropiadas para resultados de traducción
        var badWords_forTrans1 = [];
        var goodWords_forTrans1 = [];
        var badWords_forTrans2 = [];
        var goodWords_forTrans2 = [];
        var badWords_forTrans3 = [];
        var goodWords_forTrans3 = [];

        console.log("código de lenguaje original: " + arg_recog + " -> lenguaje de filtro: " + languageId);
        console.log("url: " + baseURL + languageId + badListPath);
        if (anti_sexual !== 'false') {
            // Cargar lista de palabras prohibidas
            fetch(baseURL + languageId + badListPath)
                .then( r => r.text() )
                .then( t => {
                    badWords_forRecog = t.split("\n").filter(Boolean);
                    console.log("número de palabras prohibidas cargadas: " + badWords_forRecog.length);
                });

            // Cargar lista de palabras permitidas
            fetch(baseURL + languageId + goodListPath)
                .then( r => r.text() )
                .then( t => {
                    goodWords_forRecog = t.split("\n").filter(Boolean);
                });
                
            // Cargar lista de palabras inapropiadas para traducción 1
            if(arg_trans != null) {
                const trans1LangId = getFilterLanguageId(arg_trans);
                console.log("lenguaje trans1: " + arg_trans + " -> lenguaje de filtro: " + trans1LangId);
                fetch(baseURL + trans1LangId + badListPath)
                    .then( r => r.text() )
                    .then( t => {
                        badWords_forTrans1 = t.split("\n").filter(Boolean);
                        console.log("número de palabras prohibidas Trans1 cargadas: " + badWords_forTrans1.length);
                    })
                    .catch(e => console.log("Lista de palabras prohibidas Trans1 no encontrada para: " + trans1LangId));
                    
                fetch(baseURL + trans1LangId + goodListPath)
                    .then( r => r.text() )
                    .then( t => {
                        goodWords_forTrans1 = t.split("\n").filter(Boolean);
                    })
                    .catch(e => console.log("Lista de palabras permitidas Trans1 no encontrada para: " + trans1LangId));
            }
            
            // Cargar lista de palabras inapropiadas para traducción 2
            if(arg_trans2 != null) {
                const trans2LangId = getFilterLanguageId(arg_trans2);
                console.log("lenguaje trans2: " + arg_trans2 + " -> lenguaje de filtro: " + trans2LangId);
                fetch(baseURL + trans2LangId + badListPath)
                    .then( r => r.text() )
                    .then( t => {
                        badWords_forTrans2 = t.split("\n").filter(Boolean);
                        console.log("número de palabras prohibidas Trans2 cargadas: " + badWords_forTrans2.length);
                    })
                    .catch(e => console.log("Lista de palabras prohibidas Trans2 no encontrada para: " + trans2LangId));
                    
                fetch(baseURL + trans2LangId + goodListPath)
                    .then( r => r.text() )
                    .then( t => {
                        goodWords_forTrans2 = t.split("\n").filter(Boolean);
                    })
                    .catch(e => console.log("Lista de palabras permitidas Trans2 no encontrada para: " + trans2LangId));
            }
            
            // Cargar lista de palabras inapropiadas para traducción 3
            if(arg_trans3 != null) {
                const trans3LangId = getFilterLanguageId(arg_trans3);
                console.log("lenguaje trans3: " + arg_trans3 + " -> lenguaje de filtro: " + trans3LangId);
                fetch(baseURL + trans3LangId + badListPath)
                    .then( r => r.text() )
                    .then( t => {
                        badWords_forTrans3 = t.split("\n").filter(Boolean);
                        console.log("número de palabras prohibidas Trans3 cargadas: " + badWords_forTrans3.length);
                    })
                    .catch(e => console.log("Lista de palabras prohibidas Trans3 no encontrada para: " + trans3LangId));
                    
                fetch(baseURL + trans3LangId + goodListPath)
                    .then( r => r.text() )
                    .then( t => {
                        goodWords_forTrans3 = t.split("\n").filter(Boolean);
                    })
                    .catch(e => console.log("Lista de palabras permitidas Trans3 no encontrada para: " + trans3LangId));
            }
        }


        // Reconocimiento de voz principal /////////////////////////////////////////////////
        window.SpeechRecognition = window.SpeechRecognition || webkitSpeechRecognition;

        // Web Speech API no soporta selección de dispositivo, esta función está deshabilitada
        function initializeAudioDevice() {
            console.log('Web Speech API usa solo el dispositivo de audio predeterminado');
            return Promise.resolve();
        }

        // Configuración de reconocimiento de voz ----------------------
        var recognition = new webkitSpeechRecognition();
        recognition.lang = 'ja';
        recognition.interimResults = true;
        // recognition.continuous = true;
        
        // Gestión de estado de reconocimiento
        var recognitionState = 'stopped'; // 'stopped', 'starting', 'running'
        var recognitionRestartInProgress = false; // Bandera de reinicio en progreso
        
        // Función segura de reinicio de reconocimiento
        function safeRestartRecognition(reason = 'desconocido') {
            if (recognitionRestartInProgress) {
                console.log(`Reinicio de reconocimiento omitido: ya en proceso (razón: ${reason})`);
                return;
            }
            
            console.log(`Iniciando reinicio de reconocimiento (razón: ${reason}, estado actual: ${recognitionState})`);
            recognitionRestartInProgress = true;
            
            try {
                // Detener si está ejecutándose
                if (recognitionState === 'running' || recognitionState === 'starting') {
                    recognition.stop();
                    recognitionState = 'stopped';
                }
                
                // Esperar un poco antes de reiniciar
                setTimeout(() => {
                    try {
                        if (recognition && recognitionState === 'stopped') {
                            recognitionState = 'starting';
                            recognition.start();
                            console.log(`Reinicio de reconocimiento completado (razón: ${reason})`);
                        }
                    } catch (error) {
                        console.error(`Error en reinicio de reconocimiento (razón: ${reason}):`, error);
                        recognitionState = 'stopped';
                    } finally {
                        recognitionRestartInProgress = false;
                    }
                }, 1000);
            } catch (error) {
                console.error(`Error al detener reconocimiento (razón: ${reason}):`, error);
                recognitionRestartInProgress = false;
            }
        }
        var recog_text = '';
        var recog_IM_text = '';
        var recog_conf = 0;
        var trans_text = '';
        var trans2_text = '';
        var trans3_text = '';

        var my_count = count;
        count = count + 1;

        // Otras configuraciones ----------------------------
        var isSpeechRecognitionComplete = false;
        
        // Configuración del método de traducción (controlado desde ventana principal)
        var selectedTranslationMethod = getParam('translation_method') || 'chrome'; // Obtener desde parámetro URL, predeterminado Chrome incorporado
        var chromeTranslationReady = false;
        
        console.log('Método de traducción inicial:', selectedTranslationMethod);
        
        // Iniciar temporizador de recarga de ChromeTraducción si está seleccionado al inicializar
        if (selectedTranslationMethod === 'chrome') {
            // Iniciar temporizador con retraso (después de que DOM esté listo)
            setTimeout(() => {
                startChromeTranslationReloadTimer();
            }, 1000);
        }


        // Eliminada función de recarga automática de ChromeTraducción incorporada (bug de Chrome corregido)

        // Recibir mensaje de cambio de método de traducción desde ventana principal
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'updateTranslationMethod') {
                selectedTranslationMethod = event.data.method;
                console.log('Método de traducción cambiado:', selectedTranslationMethod);
            }
        })
        
        // Manejo global de errores (para prevenir falta de memoria y caídas)
        window.addEventListener('error', function(event) {
            console.error('Error global:', event.error);
            
            // Verificar errores STATUS_BREADPOINT o relacionados con memoria
            if (event.error && event.error.message && 
                (event.error.message.includes('STATUS_BREADPOINT') || 
                 event.error.message.includes('memory') ||
                 event.error.message.includes('Out of memory'))) {
                
                console.warn('Error relacionado con memoria detectado. Ejecutando limpieza de emergencia.');
                
                // Ejecutar limpieza de emergencia
                if (window.chromeTranslator && typeof window.chromeTranslator.performMemoryCleanup === 'function') {
                    window.chromeTranslator.performMemoryCleanup();
                }
                
                // Forzar recolección de basura
                if (window.gc && typeof window.gc === 'function') {
                    window.gc();
                }
                
                // Mostrar mensaje de error
                updateTranslationStatus('Error de memoria detectado', '#ff6b6b');
            }
        });

        // Capturar rechazos de Promise no manejados
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Rechazo de Promise no manejado:', event.reason);
            
            // En caso de error relacionado con Chrome Translation API
            if (event.reason && event.reason.message && 
                event.reason.message.includes('Translation')) {
                console.warn('Error de ChromeTraducciónAPI detectado. Continuando ejecución.');
                event.preventDefault(); // Suprimir error
            }
        });
        
        // Verificar si Chrome Translation API está disponible
        if (window.chromeTranslator) {
            // Configurar callback de cambio de estado de descarga
            window.chromeTranslator.onDownloadStatusChange = function(status) {
                // Enviar mensaje a ventana principal (index.html)
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage({
                        type: 'downloadStatus',
                        status: status.status,
                        message: status.message,
                        progress: status.progress, // Agregar tasa de progreso
                        downloadedSize: status.downloadedSize, // Tamaño descargado
                        totalSize: status.totalSize, // Tamaño total
                        sourceLang: status.sourceLang,
                        targetLang: status.targetLang
                    }, '*');
                }
            };
            
            window.chromeTranslator.checkAvailability().then(available => {
                if (available) {
                    chromeTranslationReady = true;
                } else {
                    // Mostrar advertencia si ChromeTraducción está seleccionado pero no disponible
                    if (selectedTranslationMethod === 'chrome') {
                    }
                }
            }).catch(error => {
                console.error('Error de inicialización de Chrome Translation API:', error);
                chromeTranslationReady = false;
            });
        }
        
        var isTextTranslation1Complete = false;
        var isTextTranslation2Complete = false;
        var isTextTranslation3Complete = false;
        var currentInterimText = '';  // Mantener resultado temporal actual
        var lastFinalText = '';       // Mantener último resultado final

        // Sistema de gestión de temporizadores separado ----------------------------
        var speechDeleteTimerId = null;  // ID del temporizador de eliminación de texto de reconocimiento
        var translationDeleteTimerId = null;  // ID del temporizador de eliminación de texto de traducción
        var isSpeechTextCleared = false;  // Bandera si el texto de reconocimiento ya fue eliminado
        
        // Gestión independiente de barras de progreso
        var speechProgressUpdateIntervalId = null;  // ID de intervalo para actualización de barra de progreso de reconocimiento
        var speechTimerStartTime = null;  // Tiempo de inicio del temporizador de reconocimiento
        var speechTimerDuration = null;   // Duración del temporizador de reconocimiento
        
        var translationProgressUpdateIntervalId = null;  // ID de intervalo para actualización de barra de progreso de traducción
        var translationTimerStartTime = null;  // Tiempo de inicio del temporizador de traducción
        var translationTimerDuration = null;   // Duración del temporizador de traducción

        // Función para reemplazar texto de reconocimiento con espacio de ancho completo
        function clearSpeechText() {
            document.getElementById('speech_text-imb').innerHTML = '　'; // Espacio de ancho completo
            document.getElementById('speech_text-bg').innerHTML = '　';
            document.getElementById('speech_text-fg').innerHTML = '　';
            isSpeechTextCleared = true;  // Establecer bandera de eliminado
            console.log('Texto de reconocimiento limpiado (reemplazado con espacio de ancho completo)');
        }

        // Función para reemplazar texto de traducción con espacio de ancho completo
        function clearTranslationText() {
            if(arg_trans != null) {
                document.getElementById('trans_text-imb').innerHTML = '　';
                document.getElementById('trans_text-bg').innerHTML = '　';
                document.getElementById('trans_text-fg').innerHTML = '　';
            }
            if(arg_trans2 != null) {
                document.getElementById('trans_text2-imb').innerHTML = '　';
                document.getElementById('trans_text2-bg').innerHTML = '　';
                document.getElementById('trans_text2-fg').innerHTML = '　';
            }
            if(arg_trans3 != null) {
                document.getElementById('trans_text3-imb').innerHTML = '　';
                document.getElementById('trans_text3-bg').innerHTML = '　';
                document.getElementById('trans_text3-fg').innerHTML = '　';
            }
            console.log('Texto de traducción limpiado (reemplazado con espacio de ancho completo)');
        }

        // Función para reiniciar temporizador de eliminación de texto de reconocimiento
        function resetSpeechTimer() {
            if (speechDeleteTimerId !== null) {
                console.log('🔄 Temporizador de eliminación de texto de reconocimiento reiniciado (ID:' + speechDeleteTimerId + ')');
                clearTimeout(speechDeleteTimerId);
                speechDeleteTimerId = null;
            } else {
                console.log('⚪ Solicitud de reinicio de temporizador de reconocimiento (sin temporizador)');
            }
            // Reiniciar solo barra de progreso de reconocimiento
            if (speechProgressUpdateIntervalId !== null) {
                clearInterval(speechProgressUpdateIntervalId);
                speechProgressUpdateIntervalId = null;
            }
            updateTimerProgressBar(0, '🎤Esperando', 'linear-gradient(90deg, #FF6B6B 0%, #FFA07A 50%, #FFE4E1 100%)', 'speech');
        }

        // Función para reiniciar temporizador de eliminación de texto de traducción
        function resetTranslationTimer() {
            if (translationDeleteTimerId !== null) {
                console.log('🔄 Temporizador de eliminación de texto de traducción reiniciado (ID:' + translationDeleteTimerId + ')');
                clearTimeout(translationDeleteTimerId);
                translationDeleteTimerId = null;
            }
            // Reiniciar solo barra de progreso de traducción
            if (translationProgressUpdateIntervalId !== null) {
                clearInterval(translationProgressUpdateIntervalId);
                translationProgressUpdateIntervalId = null;
            }
            updateTimerProgressBar(0, '🌐Esperando', 'linear-gradient(90deg, #2196F3 0%, #64B5F6 50%, #BBDEFB 100%)', 'translation');
        }

        // Función para iniciar temporizador de eliminación de texto de reconocimiento
        function startSpeechDeleteTimer() {
            resetSpeechTimer(); // Limpiar temporizador existente
            
            if (timer != null && timer !== '') {
                var duration = parseInt(timer);
                
                if (isNaN(duration) || duration <= 0) {
                    console.log('❌ Error al iniciar temporizador de reconocimiento: configuración de tiempo inválida:', timer);
                    return;
                }
                
                speechDeleteTimerId = setTimeout(function() {
                    console.log('⏰ Temporizador de reconocimiento vencido - Limpiando texto (ID:' + speechDeleteTimerId + ')');
                    clearSpeechText();
                    speechDeleteTimerId = null;
                    updateTimerProgressBar(0, '🎤Completado', '#4CAF50', 'speech');
                    setTimeout(function() {
                        updateTimerProgressBar(0, '🎤Esperando', 'linear-gradient(90deg, #FF6B6B 0%, #FFA07A 50%, #FFE4E1 100%)', 'speech');
                    }, 1000);
                }, duration);
                
                console.log('🎤⏱️ Temporizador de eliminación de texto de reconocimiento iniciado:', duration + 'ms', '(ID:' + speechDeleteTimerId + ')');
                
                // Iniciar cuenta regresiva de barra de progreso
                startProgressBarCountdown(duration, 'speech');
            } else {
                console.log('❌ Error al iniciar temporizador de reconocimiento: sin configuración de timer (timer=' + timer + ')');
            }
        }

        // Función para iniciar temporizador de eliminación de texto de traducción
        function startTranslationDeleteTimer() {
            resetTranslationTimer(); // Limpiar temporizador existente
            
            if (timer != null && timer !== '') {
                var duration = parseInt(timer);
                
                translationDeleteTimerId = setTimeout(function() {
                    console.log('Temporizador de traducción vencido - Limpiando texto');
                    clearTranslationText();
                    translationDeleteTimerId = null;
                }, duration);
                
                console.log('🌐⏱️ Temporizador de eliminación de texto de traducción iniciado:', timer + 'ms');
                
                // Para temporizador de traducción, mostrar barra de progreso en azul
                startProgressBarCountdown(duration, 'translation');
            }
        }

        // Función de actualización de estado de traducción
        function updateTranslationStatus(status, color) {
            try {
                if (window.parent && window.parent.document) {
                    var statusElement = window.parent.document.getElementById('translationStatus');
                    if (statusElement) {
                        statusElement.innerHTML = status;
                        statusElement.style.color = color || '#666';
                    }
                }
            } catch (error) {
                console.log('Error al actualizar estado de traducción:', error);
            }
        }

        // Función de actualización de barra de progreso de temporizador (barras individuales)
        function updateTimerProgressBar(percent, text, color, type) {
            try {
                if (window.parent && window.parent.document) {
                    var barId = type === 'translation' ? 'transTimerProgressBar' : 'speechTimerProgressBar';
                    var textId = type === 'translation' ? 'transTimerProgressText' : 'speechTimerProgressText';
                    
                    var progressBar = window.parent.document.getElementById(barId);
                    var progressText = window.parent.document.getElementById(textId);
                    
                    if (progressBar && progressText) {
                        progressBar.style.width = percent + '%';
                        progressText.innerHTML = text;
                        
                        if (color) {
                            progressBar.style.background = color;
                        }
                    }
                }
            } catch (error) {
                console.log('Error al actualizar barra de progreso:', error);
            }
        }

        // Iniciar animación de cuenta regresiva de barra de progreso (versión independiente)
        function startProgressBarCountdown(duration, type) {
            var intervalId;
            var startTime;
            var timerDuration;
            
            if (type === 'translation') {
                // Detener actualización existente de barra de progreso de traducción
                if (translationProgressUpdateIntervalId !== null) {
                    clearInterval(translationProgressUpdateIntervalId);
                    translationProgressUpdateIntervalId = null;
                }
                translationTimerStartTime = Date.now();
                translationTimerDuration = duration;
                startTime = translationTimerStartTime;
                timerDuration = translationTimerDuration;
            } else {
                // Detener actualización existente de barra de progreso de reconocimiento
                if (speechProgressUpdateIntervalId !== null) {
                    clearInterval(speechProgressUpdateIntervalId);
                    speechProgressUpdateIntervalId = null;
                }
                speechTimerStartTime = Date.now();
                speechTimerDuration = duration;
                startTime = speechTimerStartTime;
                timerDuration = speechTimerDuration;
            }

            // Determinar color según tipo de temporizador
            var colorGradient;
            var typeText = '';
            if (type === 'translation') {
                colorGradient = 'linear-gradient(90deg, #2196F3 0%, #64B5F6 50%, #BBDEFB 100%)';
                typeText = '🌐';
            } else {
                colorGradient = 'linear-gradient(90deg, #FF6B6B 0%, #FFA07A 50%, #FFE4E1 100%)';
                typeText = '🎤';
            }

            // Inicializar barra de progreso
            var initialSeconds = Math.round(duration / 1000);
            updateTimerProgressBar(100, typeText + ' ' + initialSeconds + 's', colorGradient, type);

            // Actualizar barra de progreso cada 50ms (más suave)
            intervalId = setInterval(function() {
                var elapsed = Date.now() - startTime;
                var remaining = Math.max(0, timerDuration - elapsed);
                var percent = (remaining / timerDuration) * 100;
                var remainingSeconds = Math.ceil(remaining / 1000);

                if (remaining > 0) {
                    // Cambiar color según tiempo restante
                    var urgencyLevel = remaining / timerDuration;
                    var displayColor;
                    if (urgencyLevel > 0.5) {
                        displayColor = colorGradient;
                    } else if (urgencyLevel > 0.2) {
                        displayColor = 'linear-gradient(90deg, #FFA726 0%, #FFB74D 50%, #FFE0B2 100%)';
                    } else {
                        displayColor = 'linear-gradient(90deg, #F44336 0%, #EF5350 50%, #FFCDD2 100%)';
                    }
                    
                    updateTimerProgressBar(percent, typeText + ' ' + remainingSeconds + 's', displayColor, type);
                } else {
                    updateTimerProgressBar(0, typeText + ' ¡Eliminado!', '#D32F2F', type);
                    clearInterval(intervalId);
                    
                    // Limpiar ID de intervalo
                    if (type === 'translation') {
                        translationProgressUpdateIntervalId = null;
                    } else {
                        speechProgressUpdateIntervalId = null;
                    }
                }
            }, 50);
            
            // Guardar ID de intervalo
            if (type === 'translation') {
                translationProgressUpdateIntervalId = intervalId;
            } else {
                speechProgressUpdateIntervalId = intervalId;
            }
        }



        function shouldClearText() {
            // Verificar si cada proceso está habilitado y si está completo
            var recogComplete = isSpeechRecognitionComplete;
            var trans1Complete = arg_trans != null ? isTextTranslation1Complete : true;
            var trans2Complete = arg_trans2 != null ? isTextTranslation2Complete : true;
            var trans3Complete = arg_trans3 != null ? isTextTranslation3Complete : true;

            return recogComplete && trans1Complete && trans2Complete && trans3Complete;
        }


        stop_recog = function() {
            console.log("¡detenido por pausa corta!");
            recognition.stop();
            // No iniciar temporizador cuando se detiene por pausa corta (ya iniciado en onspeechend/onsoundend)
        };

        ///////////////////////////////////////////////////////////
        // Manejo de varios eventos --------------------------------- 
        // Inicio de audio y reconocimiento
        recognition.onstart = () => {
            console.log("onstart cnt:" + String(my_count));
            recognitionState = 'running';
            // No reiniciar temporizador al inicio de reconocimiento (reiniciar en detección real de audio)
        }
        recognition.onaudiostart = () => {
            console.log("onaudiostart cnt:" + String(my_count));
        }
        recognition.onsoundstart = () => {
            console.log("🔊 onsoundstart cnt:" + String(my_count));
            // Reiniciar temporizador de audio al inicio de detección de sonido
            resetSpeechTimer();
        }
        recognition.onspeechstart = () => {
            console.log("🗣️ onspeechstart cnt:" + String(my_count));
            // Reiniciar temporizador de audio al inicio de habla
            resetSpeechTimer();
        }
        
        // Fin de audio y reconocimiento
        recognition.onspeechend = () => {
            console.log("🔇 onspeechend cnt:" + String(my_count));
            // No iniciar temporizador al final del habla (iniciar al obtener resultado final)
        }
        recognition.onsoundend = () => {
            console.log("🔕 onsoundend cnt:" + String(my_count));
            // No iniciar temporizador al final de detección de sonido (iniciar al obtener resultado final)
        }
        recognition.onaudioend = () => {
            console.log("onaudioend cnt:" + String(my_count));
        }
        recognition.onend = () => {
            console.log("onend cnt:" + String(my_count));
            recognitionState = 'stopped';
            
            // No iniciar temporizador al final del reconocimiento (ya iniciado en onspeechend/onsoundend)
            
            // Reiniciar banderas
            isSpeechRecognitionComplete = false;
            isTextTranslation1Complete = false;
            isTextTranslation2Complete = false;
            isTextTranslation3Complete = false;
            
            // Reiniciar de forma segura
            setTimeout(() => {
                my_count = count;
                count = count + 1;
                safeRestartRecognition('finalización normal');
            }, 100);
        }

        // Errores, etc.
        recognition.onerror = (event) => {
            console.log("onerror cnt:" + String(my_count) + " error:" + event.error);
            recognitionState = 'stopped';
            
            // Manejar según tipo de error
            if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                console.log('Se requiere permiso de acceso al micrófono');
                return; // No reiniciar
            }
            
            // Reiniciar de forma segura para otros errores
            safeRestartRecognition(`Error: ${event.error}`);
        }
        recognition.onnomatch = () => {
            console.log("onnomatch cnt:" + String(my_count));
            // Continuar sin detener en caso de nomatch
        }


        // Configuración de lenguaje ----------------------------
        if (arg_recog != null) {
            recognition.lang = arg_recog;
            trans_sourcelang = recognition.lang;
            console.log('Configuración de lenguaje de reconocimiento completada:', recognition.lang, 'trans_sourcelang:', trans_sourcelang);
        }
        if (arg_trans != null) {
            trans_destlang = arg_trans;
        }
        if (arg_trans2 != null) {
            trans2_destlang = arg_trans2;
        }
        if (arg_trans3 != null) {
            trans3_destlang = arg_trans3;
        }

        // Cuando llegan resultados de reconocimiento ------------------
        recognition.onresult = function(event) {
            var results = event.results;
            
            // Construir resultado más reciente (resultado final + resultado temporal)
            var finalText = '';
            var interimText = '';
            var latestConfidence = 0;
            
            for (var i = 0; i < results.length; i++) {
                var transcript = results[i][0].transcript;
                var confidence = results[i][0].confidence || 0;
                
                if (results[i].isFinal) {
                    finalText += transcript;
                    if (confidence > 0) {
                        latestConfidence = confidence;
                    }
                } else {
                    interimText += transcript;
                }
            }
            
            // Aplicar filtrado
            var filteredFinalText = applyContentFilter(finalText);
            var filteredInterimText = applyContentFilter(interimText);
            
            // Construir texto para mostrar (parte final filtrada + parte temporal filtrada)
            var displayText = filteredFinalText + filteredInterimText;
            var recog_text = displayText;  // Para compatibilidad con procesamiento posterior


                // Verificar si el resultado más reciente contiene resultado final
                var hasNewFinal = false;
                for (var j = event.resultIndex; j < results.length; j++) {
                    if (results[j].isFinal) {
                        hasNewFinal = true;
                        break;
                    }
                }
                
                // #################################################################
                // Cuando llega resultado final de reconocimiento ###############################################
                if (hasNewFinal)
                {
                    // Iniciar temporizador de reconocimiento al obtener resultado final (considerado fin del habla)
                    console.log('🎤⚙️ Obtenido resultado final - Iniciando temporizador de reconocimiento (texto:"' + finalText + '")');
                    
                    // Iniciar temporizador solo si el resultado final no está vacío
                    if (finalText && finalText.trim() !== '') {
                        startSpeechDeleteTimer();
                        isSpeechTextCleared = false;  // Se muestra nuevo texto, reiniciar bandera
                    } else {
                        console.log('⚠️ Resultado final vacío, omitiendo inicio de temporizador');
                    }
                    // Mostrar resultado de reconocimiento (filtrado) ---------------------
                    var displayTextWithConfidence = filteredFinalText;
                    if (arg_showConfidence === 'true' && latestConfidence > 0) {
                        displayTextWithConfidence += ` (Confianza: ${Math.round(latestConfidence * 100)}%)`;
                    }
                    document.getElementById('speech_text-imb').innerHTML = displayTextWithConfidence;
                    document.getElementById('speech_text-bg').innerHTML = displayTextWithConfidence;
                    document.getElementById('speech_text-fg').innerHTML = displayTextWithConfidence;
                    isSpeechRecognitionComplete = true; // Actualizar bandera
                    
                    // Enviar texto a ventana de ChromeTraducción
                    if (window.parent && window.parent !== window) {
                        // Enviar desde iframe a ventana principal
                        window.parent.postMessage({
                            type: 'speechText',
                            text: filteredFinalText
                        }, '*');
                        
                        // Verificar si ventana de ChromeTraducción está abierta
                        window.parent.postMessage({
                            type: 'checkChromeTranslation'
                        }, '*');
                    }
                    
                    // Usar solo texto final confirmado para procesamiento de traducción (filtrado)
                    recog_text = filteredFinalText;
                    lastFinalText = filteredFinalText;  // Para mostrar, usar texto filtrado


                    // Enviar comentario a bouyomi-chan (filtrado)
                    if(bouyomi == "true") {
                        let bouyomiChanClient = new BouyomiChanClient();
                        bouyomiChanClient.talk(recog_text);
                    }

                    // Bandera de procesamiento de traducción (prevenir ejecución duplicada)
                    let translationProcessed = false;
                    
                    // Ejecutar procesamiento de traducción según método seleccionado
                    if (selectedTranslationMethod === 'chrome' && chromeTranslationReady) {
                        // Verificar que al menos un lenguaje de traducción esté configurado
                        if (arg_trans != null || arg_trans2 != null || arg_trans3 != null) {
                            translationProcessed = true; // Registrar que se ejecutó ChromeTraducción
                            
                            // Estado de inicio de traducción (Chrome)
                            var activeTranslations = [];
                            if(arg_trans != null) activeTranslations.push('1');
                            if(arg_trans2 != null) activeTranslations.push('2');
                            if(arg_trans3 != null) activeTranslations.push('3');
                            if(activeTranslations.length > 0) {
                                updateTranslationStatus('Traducción Chrome en progreso(' + activeTranslations.join(',') + ')', '#4CAF50');
                            }
                            
                            // Obtener lenguaje fuente una sola vez
                            const sourceLang = window.chromeTranslator.normalizeLanguageCode(trans_sourcelang);
                            
                            // Procesamiento de lenguaje de traducción 1
                            if (arg_trans != null) {
                                const targetLang = window.chromeTranslator.normalizeLanguageCode(arg_trans);
                                
                                // Omitir si lenguaje de reconocimiento y traducción son iguales
                                if (sourceLang === targetLang) {
                                    // Mostrar texto original tal cual
                                    const filteredText = applyTranslationFilter(recog_text, 1);
                                    document.getElementById('trans_text-imb').innerHTML = filteredText;
                                    document.getElementById('trans_text-bg').innerHTML = filteredText;
                                    document.getElementById('trans_text-fg').innerHTML = filteredText;
                                    isTextTranslation1Complete = true;
                                    startTranslationDeleteTimer();
                                } else {
                                    window.chromeTranslator.translate(recog_text, sourceLang, targetLang)
                                        .then(translatedText => {
                                            // Mostrar resultado de traducción
                                            const filteredText = applyTranslationFilter(translatedText, 1);
                                            document.getElementById('trans_text-imb').innerHTML = filteredText;
                                            document.getElementById('trans_text-bg').innerHTML = filteredText;
                                            document.getElementById('trans_text-fg').innerHTML = filteredText;
                                            isTextTranslation1Complete = true;
                                            
                                            updateTranslationStatus('Traducción Chrome completada', '#4CAF50');
                                            startTranslationDeleteTimer();
                                        })
                                        .catch(error => {
                                            console.error('Error de Traducción AI Chrome:', error);
                                            updateTranslationStatus('Error de Traducción Chrome', '#ff0000');
                                            // Usar API GAS como respaldo
                                            translationProcessed = false; // Tratar como no procesado en caso de error
                                        });
                                }
                            }
                            
                            // Procesamiento de lenguaje de traducción 2
                            if (arg_trans2 != null) {
                                const targetLang2 = window.chromeTranslator.normalizeLanguageCode(arg_trans2);
                                
                                // Omitir si lenguaje de reconocimiento y traducción son iguales
                                if (sourceLang === targetLang2) {
                                    const filteredText2 = applyTranslationFilter(recog_text, 2);
                                    document.getElementById('trans_text2-imb').innerHTML = filteredText2;
                                    document.getElementById('trans_text2-bg').innerHTML = filteredText2;
                                    document.getElementById('trans_text2-fg').innerHTML = filteredText2;
                                    isTextTranslation2Complete = true;
                                    startTranslationDeleteTimer();
                                } else {
                                    window.chromeTranslator.canTranslate(sourceLang, targetLang2).then(canTranslate2 => {
                                        if (canTranslate2) {
                                            return window.chromeTranslator.translate(recog_text, sourceLang, targetLang2);
                                        }
                                    }).then(translatedText2 => {
                                        if (translatedText2) {
                                            const filteredText2 = applyTranslationFilter(translatedText2, 2);
                                            document.getElementById('trans_text2-imb').innerHTML = filteredText2;
                                            document.getElementById('trans_text2-bg').innerHTML = filteredText2;
                                            document.getElementById('trans_text2-fg').innerHTML = filteredText2;
                                            isTextTranslation2Complete = true;
                                            startTranslationDeleteTimer();
                                        }
                                    }).catch(error => {
                                        console.error('Error de Traducción Chrome Traducción2:', error);
                                    });
                                }
                            }
                            
                            // Procesamiento de lenguaje de traducción 3
                            if (arg_trans3 != null) {
                                const targetLang3 = window.chromeTranslator.normalizeLanguageCode(arg_trans3);
                                
                                // Omitir si lenguaje de reconocimiento y traducción son iguales
                                if (sourceLang === targetLang3) {
                                    const filteredText3 = applyTranslationFilter(recog_text, 3);
                                    document.getElementById('trans_text3-imb').innerHTML = filteredText3;
                                    document.getElementById('trans_text3-bg').innerHTML = filteredText3;
                                    document.getElementById('trans_text3-fg').innerHTML = filteredText3;
                                    isTextTranslation3Complete = true;
                                    startTranslationDeleteTimer();
                                } else {
                                    window.chromeTranslator.canTranslate(sourceLang, targetLang3).then(canTranslate3 => {
                                        if (canTranslate3) {
                                            return window.chromeTranslator.translate(recog_text, sourceLang, targetLang3);
                                        }
                                    }).then(translatedText3 => {
                                        if (translatedText3) {
                                            const filteredText3 = applyTranslationFilter(translatedText3, 3);
                                            document.getElementById('trans_text3-imb').innerHTML = filteredText3;
                                            document.getElementById('trans_text3-bg').innerHTML = filteredText3;
                                            document.getElementById('trans_text3-fg').innerHTML = filteredText3;
                                            isTextTranslation3Complete = true;
                                            startTranslationDeleteTimer();
                                        }
                                    }).catch(error => {
                                        console.error('Error de Traducción Chrome Traducción3:', error);
                                    });
                                }
                            }
                        }  // Fin de verificación de configuración de lenguaje de traducción para ChromeTraducción
                    }  // Fin de procesamiento de ChromeTraducción
                    // Si está seleccionada API GAS Traducción o ocurrió error en ChromeTraducción
                    else if((selectedTranslationMethod === 'gas' || !translationProcessed) && gas_key != null){
                        
                        // Estado de inicio de traducción (GAS)
                        var activeTranslations = [];
                        if(arg_trans != null) activeTranslations.push('1');
                        if(arg_trans2 != null) activeTranslations.push('2');
                        if(arg_trans3 != null) activeTranslations.push('3');
                        if(activeTranslations.length > 0) {
                            updateTranslationStatus('Traducción GAS en progreso(' + activeTranslations.join(',') + ')', '#0066cc');
                        }

                        // Lenguaje de traducción 1
                        if(arg_trans != null){
                            const processedText = applyCustomDictionary(recog_text);
                            const sourceLang = getTranslationLanguageId(trans_sourcelang);
                            
                            // Si lenguaje de reconocimiento y traducción son iguales, mostrar directamente sin llamar API
                            if(sourceLang === trans_destlang) {
                                console.log('API GAS: Lenguaje de reconocimiento y traducción iguales, omitiendo traducción');
                                const filteredText = applyTranslationFilter(recog_text, 1);
                                document.getElementById('trans_text-imb').innerHTML = filteredText;
                                document.getElementById('trans_text-bg').innerHTML = filteredText;
                                document.getElementById('trans_text-fg').innerHTML = filteredText;
                                isTextTranslation1Complete = true;
                                startTranslationDeleteTimer();
                            } else {
                                query = TRANS_URL + '?text=' + encodeURIComponent(processedText) + '&source=' + sourceLang + '&target=' + trans_destlang;
                                request.open('GET', query, true);

                            request.onreadystatechange = function(){
                                if (request.readyState === 4 && request.status === 200){

                                    var responseText1 = request.responseText;

                                    // Verificar si es formato JSON y extraer translatedText si es JSON
                                    try {
                                        var jsonResponse = JSON.parse(responseText1);
                                        if (jsonResponse.translatedText) {
                                            responseText1 = jsonResponse.translatedText;
                                            var translatedCount = jsonResponse.translatedCount;
                                            document.getElementById('translationCount').innerHTML = translatedCount;
                                            console.log('translatedCount(1):'+translatedCount);
                                        }
                                    } catch (e) {
                                        // No hacer nada si no es formato JSON
                                    }

                                    // Volver a mostrar solo si texto de reconocimiento no fue eliminado
                                    if (!isSpeechTextCleared) {
                                        document.getElementById('speech_text-imb').innerHTML = lastFinalText;
                                        document.getElementById('speech_text-bg').innerHTML = lastFinalText;
                                        document.getElementById('speech_text-fg').innerHTML = lastFinalText;
                                    }
                                    
                                    // Aplicar filtrado a resultado de traducción 1
                                    var filteredResponseText1 = applyTranslationFilter(responseText1, 1);
                                    document.getElementById('trans_text-imb').innerHTML =  filteredResponseText1;
                                    document.getElementById('trans_text-bg').innerHTML =  filteredResponseText1;
                                    document.getElementById('trans_text-fg').innerHTML =  filteredResponseText1;
                                    isTextTranslation1Complete = true; // Actualizar bandera
                                    
                                    // Iniciar temporizador de traducción al completar traducción 1
                                    startTranslationDeleteTimer();
                                    
                                    // Verificar finalización de traducción
                                    var completedTranslations = 0;
                                    var totalTranslations = 0;
                                    if(arg_trans != null) { totalTranslations++; if(isTextTranslation1Complete) completedTranslations++; }
                                    if(arg_trans2 != null) { totalTranslations++; if(isTextTranslation2Complete) completedTranslations++; }
                                    if(arg_trans3 != null) { totalTranslations++; if(isTextTranslation3Complete) completedTranslations++; }
                                    
                                    if(completedTranslations === totalTranslations) {
                                        updateTranslationStatus('Traducción completada', '#00aa00');
                                    }
                                } else if (request.readyState === 4) {
                                    // Manejo de error
                                    if (request.status === 429) {
                                        updateTranslationStatus('Error de límite de API', '#cc0000');
                                    } else if (request.status === 403) {
                                        updateTranslationStatus('Error de autenticación API', '#cc0000');
                                    } else {
                                        updateTranslationStatus('Error de traducción(HTTP:' + request.status + ')', '#cc0000');
                                    }
                                }
                            }
                            request.send(null);
                            }
                        }

                        // Lenguaje de traducción 2
                        if(arg_trans2 != null){
                            const processedText2 = applyCustomDictionary(recog_text);
                            const sourceLang2 = getTranslationLanguageId(trans_sourcelang);
                            
                            // Si lenguaje de reconocimiento y traducción son iguales, mostrar directamente sin llamar API
                            if(sourceLang2 === trans2_destlang) {
                                console.log('API GAS: Lenguaje de reconocimiento y traducción 2 iguales, omitiendo traducción');
                                const filteredText2 = applyTranslationFilter(recog_text, 2);
                                document.getElementById('trans_text2-imb').innerHTML = filteredText2;
                                document.getElementById('trans_text2-bg').innerHTML = filteredText2;
                                document.getElementById('trans_text2-fg').innerHTML = filteredText2;
                                isTextTranslation2Complete = true;
                                startTranslationDeleteTimer();
                            } else {
                                query2 = TRANS_URL + '?text=' + encodeURIComponent(processedText2) + '&source=' + sourceLang2 + '&target=' + trans2_destlang;
                            request2.open('GET', query2, true);

                            request2.onreadystatechange = function(){
                                if (request2.readyState === 4 && request2.status === 200){

                                    var responseText2 = request2.responseText;

                                    // Verificar si es formato JSON y extraer translatedText si es JSON
                                    try {
                                        var jsonResponse = JSON.parse(responseText2);
                                        if (jsonResponse.translatedText) {
                                            responseText2 = jsonResponse.translatedText;
                                            document.getElementById('translationCount').innerHTML = jsonResponse.translatedCount;
                                            var translatedCount2 = jsonResponse.translatedCount;
                                            document.getElementById('translationCount').innerHTML = translatedCount2;
                                            console.log('translatedCount(2):'+translatedCount2);
                                        }
                                    } catch (e) {
                                        // No hacer nada si no es formato JSON
                                    }

                                    // Volver a mostrar solo si texto de reconocimiento no fue eliminado
                                    if (!isSpeechTextCleared) {
                                        document.getElementById('speech_text-imb').innerHTML = lastFinalText;
                                        document.getElementById('speech_text-bg').innerHTML = lastFinalText;
                                        document.getElementById('speech_text-fg').innerHTML = lastFinalText;
                                    }
                                    
                                    // Aplicar filtrado a resultado de traducción 2
                                    var filteredResponseText2 = applyTranslationFilter(responseText2, 2);
                                    document.getElementById('trans_text2-imb').innerHTML = filteredResponseText2;
                                    document.getElementById('trans_text2-bg').innerHTML = filteredResponseText2;
                                    document.getElementById('trans_text2-fg').innerHTML = filteredResponseText2;
                                    isTextTranslation2Complete = true; // Actualizar bandera
                                    
                                    // Reanudar inicio de temporizador de traducción al completar traducción 2
                                    startTranslationDeleteTimer();
                                    
                                    // Verificar finalización de traducción
                                    var completedTranslations = 0;
                                    var totalTranslations = 0;
                                    if(arg_trans != null) { totalTranslations++; if(isTextTranslation1Complete) completedTranslations++; }
                                    if(arg_trans2 != null) { totalTranslations++; if(isTextTranslation2Complete) completedTranslations++; }
                                    if(arg_trans3 != null) { totalTranslations++; if(isTextTranslation3Complete) completedTranslations++; }
                                    
                                    if(completedTranslations === totalTranslations) {
                                        updateTranslationStatus('Traducción completada', '#00aa00');
                                    }
                                } else if (request2.readyState === 4) {
                                    // Manejo de error
                                    if (request2.status === 429) {
                                        updateTranslationStatus('Error de límite de API', '#cc0000');
                                    } else if (request2.status === 403) {
                                        updateTranslationStatus('Error de autenticación API', '#cc0000');
                                    } else {
                                        updateTranslationStatus('Error de traducción(HTTP:' + request2.status + ')', '#cc0000');
                                    }
                                }
                            }
                            request2.send(null);
                            }
                        }

                        // Lenguaje de traducción 3
                        if(arg_trans3 != null){
                            const processedText3 = applyCustomDictionary(recog_text);
                            const sourceLang3 = getTranslationLanguageId(trans_sourcelang);
                            
                            // Si lenguaje de reconocimiento y traducción son iguales, mostrar directamente sin llamar API
                            if(sourceLang3 === trans3_destlang) {
                                console.log('API GAS: Lenguaje de reconocimiento y traducción 3 iguales, omitiendo traducción');
                                const filteredText3 = applyTranslationFilter(recog_text, 3);
                                document.getElementById('trans_text3-imb').innerHTML = filteredText3;
                                document.getElementById('trans_text3-bg').innerHTML = filteredText3;
                                document.getElementById('trans_text3-fg').innerHTML = filteredText3;
                                isTextTranslation3Complete = true;
                                startTranslationDeleteTimer();
                            } else {
                                query3 = TRANS_URL + '?text=' + encodeURIComponent(processedText3) + '&source=' + sourceLang3 + '&target=' + trans3_destlang;
                            request3.open('GET', query3, true);

                            request3.onreadystatechange = function(){
                                if (request3.readyState === 4 && request3.status === 200){

                                    var responseText3 = request3.responseText;

                                    // Verificar si es formato JSON y extraer translatedText si es JSON
                                    try {
                                        var jsonResponse = JSON.parse(responseText3);
                                        if (jsonResponse.translatedText) {
                                            responseText3 = jsonResponse.translatedText;
                                            document.getElementById('translationCount').innerHTML = jsonResponse.translatedCount;
                                            var translatedCount3 = jsonResponse.translatedCount;
                                            document.getElementById('translationCount').innerHTML = translatedCount3;
                                            console.log('translatedCount(3):'+translatedCount3);
                                        }
                                    } catch (e) {
                                        // No hacer nada si no es formato JSON
                                    }

                                    // Volver a mostrar solo si texto de reconocimiento no fue eliminado
                                    if (!isSpeechTextCleared) {
                                        document.getElementById('speech_text-imb').innerHTML = lastFinalText;
                                        document.getElementById('speech_text-bg').innerHTML = lastFinalText;
                                        document.getElementById('speech_text-fg').innerHTML = lastFinalText;
                                    }
                                    
                                    // Aplicar filtrado a resultado de traducción 3
                                    var filteredResponseText3 = applyTranslationFilter(responseText3, 3);
                                    document.getElementById('trans_text3-imb').innerHTML = filteredResponseText3;
                                    document.getElementById('trans_text3-bg').innerHTML = filteredResponseText3;
                                    document.getElementById('trans_text3-fg').innerHTML = filteredResponseText3;
                                    isTextTranslation3Complete = true; // Actualizar bandera
                                    
                                    // Reanudar inicio de temporizador de traducción al completar traducción 3
                                    startTranslationDeleteTimer();
                                    
                                    // Verificar finalización de traducción
                                    var completedTranslations = 0;
                                    var totalTranslations = 0;
                                    if(arg_trans != null) { totalTranslations++; if(isTextTranslation1Complete) completedTranslations++; }
                                    if(arg_trans2 != null) { totalTranslations++; if(isTextTranslation2Complete) completedTranslations++; }
                                    if(arg_trans3 != null) { totalTranslations++; if(isTextTranslation3Complete) completedTranslations++; }
                                    
                                    if(completedTranslations === totalTranslations) {
                                        updateTranslationStatus('Traducción completada', '#00aa00');
                                    }
                                } else if (request3.readyState === 4) {
                                    // Manejo de error
                                    if (request3.status === 429) {
                                        updateTranslationStatus('Error de límite de API', '#cc0000');
                                    } else if (request3.status === 403) {
                                        updateTranslationStatus('Error de autenticación API', '#cc0000');
                                    } else {
                                        updateTranslationStatus('Error de traducción(HTTP:' + request3.status + ')', '#cc0000');
                                    }
                                }
                            }
                            request3.send(null);
                            }
                        }

                    } else {
                        document.getElementById('speech_text-imb').innerHTML = filteredFinalText;
                        document.getElementById('speech_text-bg').innerHTML = filteredFinalText;
                        document.getElementById('speech_text-fg').innerHTML = filteredFinalText;
                        // Estado cuando no hay API KEY
                        updateTranslationStatus('Sin API KEY', '#999');
                    }

                }
                // #################################################################
                // Cuando llegan resultados temporales de reconocimiento ###############################################
                else
                {
                    // Reiniciar temporizador de reconocimiento al obtener resultado temporal (porque hay entrada de audio en progreso)
                    console.log('🔄 Obtenido resultado temporal - Reiniciando temporizador (texto:"' + displayText + '")');
                    resetSpeechTimer();
                    // Eliminar tiempo de espera para "detener reconocimiento forzadamente cuando llega pausa corta" -------
                    if(short_pause != null && short_pause !== '') {
                        clearTimeout(id_stop_recog);
                        // Configurar tiempo de espera para detención por pausa corta
                        id_stop_recog = setTimeout(stop_recog, parseInt(short_pause));
                        console.log('Temporizador de pausa corta configurado:', short_pause + 'ms');
                    }

                    // Mostrar resultado temporal (parte final filtrada + parte temporal filtrada claramente diferenciadas)
                    if(displayText !== ""){
                        var displayHtml = '';
                        if (filteredFinalText !== '') {
                            displayHtml += filteredFinalText;
                        }
                        if (filteredInterimText !== '') {
                            displayHtml += ' << ' + filteredInterimText + ' >>';
                        }
                        
                        document.getElementById('speech_text-imb').innerHTML = displayHtml;
                        document.getElementById('speech_text-bg').innerHTML = displayHtml;
                        document.getElementById('speech_text-fg').innerHTML = displayHtml;
                    }
                }
            // Integrado en un solo bucle
        }


        // Iniciar reconocimiento después de inicializar dispositivo de audio
        initializeAudioDevice().then(() => {
            recognitionState = 'starting';
            recognition.start();
            console.log("inicio de reconocimiento: cnt:" + String(my_count));
            
            // Configurar estado inicial
            if (gas_key != null && gas_key !== '') {
                updateTranslationStatus('En espera', '#666');
            } else {
                updateTranslationStatus('Sin API KEY', '#999');
            }
        }).catch(() => {
            // Iniciar con dispositivo predeterminado incluso si hay error
            recognitionState = 'starting';
            recognition.start();
            console.log("inicio de reconocimiento (dispositivo predeterminado): cnt:" + String(my_count));
            
            // Configurar estado inicial
            if (gas_key != null && gas_key !== '') {
                updateTranslationStatus('En espera', '#666');
            } else {
                updateTranslationStatus('Sin API KEY', '#999');
            }
        });

    </script> 
</head>
 





<body>
    <div class="big" id="result_text">
        <table id="text_table" class="btm_table" style="overflow:hidden;">
            <tr><td id="tbl_td" align="center" valign='bottom'>
                <div id="speech_text">
                    <div class="stroke-single-bg" id="speech_text-bg"></div> 
                    <div class="stroke-single-fg" id="speech_text-fg"></div>
                    <div class="stroke-single-imb" id="speech_text-imb"></div> 
                </div>

                <div id="trans_text">
                    <div class="stroke-single-bg" id="trans_text-bg"></div>  
                    <div class="stroke-single-fg" id="trans_text-fg"></div>  
                    <div class="stroke-single-imb" id="trans_text-imb"></div>  
                </div>

                <div id="trans_text2">
                    <div class="stroke-single-bg" id="trans_text2-bg"></div>  
                    <div class="stroke-single-fg" id="trans_text2-fg"></div>  
                    <div class="stroke-single-imb" id="trans_text2-imb"></div>  
                </div>

                <div id="trans_text3">
                    <div class="stroke-single-bg" id="trans_text3-bg"></div>  
                    <div class="stroke-single-fg" id="trans_text3-fg"></div>  
                    <div class="stroke-single-imb" id="trans_text3-imb"></div>  
                </div>
            </td></tr>
        </table>
    </div>

    <!-- Gestión de contador de traducciones -->
    <div id="translationCount" style="display: none;"></div>

</body>









<!-- ############## JavaScript al final ############## -->
<script type="text/javascript">

// Mostrar información de versión ---------------------------------
const SoftwareTitle = "Hola";
const SoftwareVersion = "";
const SoftwareDeveloper = ""

// Sobre limitaciones de dispositivo al usar Web Speech API
console.log('Reconocimiento de voz: Web Speech API usa solo dispositivo de audio predeterminado');
console.log('Para cambiar dispositivo, cambiar dispositivo predeterminado en configuración del navegador o SO.');

const speech_text_first = "" + SoftwareTitle + " " + SoftwareVersion + "" + "";
document.getElementById('speech_text-bg').innerHTML = speech_text_first;
document.getElementById('speech_text-fg').innerHTML = speech_text_first;
document.getElementById('speech_text-imb').innerHTML = speech_text_first;

const trans1_text_first = SoftwareDeveloper;
document.getElementById('trans_text-bg').innerHTML = trans1_text_first
document.getElementById('trans_text-fg').innerHTML = trans1_text_first
document.getElementById('trans_text-imb').innerHTML = trans1_text_first

const trans2_text_first = "[Resultado mostrado aquí (Traducción 2)]";
document.getElementById('trans_text2-bg').innerHTML = trans2_text_first;
document.getElementById('trans_text2-fg').innerHTML = trans2_text_first;
document.getElementById('trans_text2-imb').innerHTML = trans2_text_first;

const trans3_text_first = "[Resultado mostrado aquí (Traducción 3)]";
document.getElementById('trans_text3-bg').innerHTML = trans3_text_first;
document.getElementById('trans_text3-fg').innerHTML = trans3_text_first;
document.getElementById('trans_text3-imb').innerHTML = trans3_text_first;


// Eliminar texto de visualización inicial si no se usa lenguaje objetivo /////
if (getParam('trans') == null) {
    document.getElementById('trans_text-bg').innerHTML = '';
    document.getElementById('trans_text-fg').innerHTML = '';
    document.getElementById('trans_text-imb').innerHTML = '';
}
if (getParam('trans2') == null) {
    document.getElementById('trans_text2-bg').innerHTML = '';
    document.getElementById('trans_text2-fg').innerHTML = '';
    document.getElementById('trans_text2-imb').innerHTML = '';
}
if (getParam('trans3') == null) {
    document.getElementById('trans_text3-bg').innerHTML = '';
    document.getElementById('trans_text3-fg').innerHTML = '';
    document.getElementById('trans_text3-imb').innerHTML = '';
}

// Cambiar estilo de visualización ---------------------------------
if (getParam('bgcolor') != null){
    document.bgColor = getParam('bgcolor');
}

if (getParam('v_align') == "top"){
    document.getElementById("text_table").style.bottom = -1;
} else if(getParam('v_align') == "bottom"){
    document.getElementById("text_table").style.bottom = 0;
}

if (getParam('textAlign') != null){
    document.getElementById("text_table").style.textAlign = getParam('textAlign');
    document.getElementById("tbl_td").style.textAlign = getParam('textAlign');
    if(getParam('textAlign') == "right"){
        document.getElementById("text_table").style.direction = "rtl";
        document.getElementById("tbl_td").style.direction = "rtl";
        document.body.style.direction = "rtl";
    }
}

if (getParam('whiteSpace') != null){
    document.getElementById("text_table").style.whiteSpace = getParam('whiteSpace');
}

// Fuente para ajuste de altura (mismo color que fondo) ############################################
// Texto de reconocimiento -------
if (getParam('bgcolor') != null){
    document.getElementById("speech_text-imb").style.webkitTextStrokeColor = getParam('bgcolor');
    document.getElementById("speech_text-imb").style.color = getParam('bgcolor');
}
if (getParam('st_width1') != null){
    document.getElementById("speech_text-imb").style.webkitTextStrokeWidth = getParam('st_width1') + 'pt';
}

// Texto de resultado de traducción -------
if (getParam('bgcolor') != null){
    document.getElementById("trans_text-imb").style.webkitTextStrokeColor = getParam('bgcolor');
    document.getElementById("trans_text-imb").style.color = getParam('bgcolor');
}
if (getParam('st_width2') != null){
    document.getElementById("trans_text-imb").style.webkitTextStrokeWidth = getParam('st_width2') + 'pt';
}

// Texto de resultado de traducción (segundo lenguaje) -------
if (getParam('bgcolor') != null){
    document.getElementById("trans_text2-imb").style.webkitTextStrokeColor = getParam('bgcolor');
    document.getElementById("trans_text2-imb").style.color = getParam('bgcolor');
}
if (getParam('st_width3') != null){
    document.getElementById("trans_text2-imb").style.webkitTextStrokeWidth = getParam('st_width3') + 'pt';
}

// Texto de resultado de traducción (tercer lenguaje) -------
if (getParam('bgcolor') != null){
    document.getElementById("trans_text3-imb").style.webkitTextStrokeColor = getParam('bgcolor');
    document.getElementById("trans_text3-imb").style.color = getParam('bgcolor');
}
if (getParam('st_width4') != null){
    document.getElementById("trans_text3-imb").style.webkitTextStrokeWidth = getParam('st_width4') + 'pt';
}



// Configuración de visualización ############################################
// General ----------------

// Resultado de reconocimiento ----------------
if (getParam('speech_text_font') != null){
    var fontValue = getParam('speech_text_font');
    console.log('[DEBUG] speech_text_font desde URL:', fontValue);
    
    // Eliminar barras invertidas
    fontValue = fontValue.replace(/\\\\/g, '');
    
    // Configurar nombre de fuente correctamente (agregar comillas)
    // Para fuente Klee, convertir a nombre correcto
    if (fontValue.toLowerCase() === 'klee') {
        fontValue = 'Klee';  // En macOS comienza con mayúscula
    }
    var fontFamily = '"' + fontValue + '", sans-serif';
    document.getElementById("speech_text").style.fontFamily = fontFamily;
    
    // Aplicar también a elementos hijos
    var bgElement = document.getElementById("speech_text-bg");
    var fgElement = document.getElementById("speech_text-fg");
    var imbElement = document.getElementById("speech_text-imb");
    
    if (bgElement) bgElement.style.fontFamily = fontFamily;
    if (fgElement) fgElement.style.fontFamily = fontFamily;
    if (imbElement) imbElement.style.fontFamily = fontFamily;
    
    console.log('[DEBUG] Fuente aplicada a speech_text:', document.getElementById("speech_text").style.fontFamily);
    console.log('[DEBUG] Fuente aplicada a speech_text-fg:', fgElement ? fgElement.style.fontFamily : 'elemento no encontrado');
}

if (getParam('size1') != null){
    document.getElementById("speech_text").style.fontSize = getParam('size1') + 'pt';
}

if (getParam('weight1') != null){
    document.getElementById("speech_text").style.fontWeight = getParam('weight1');
}

if (getParam('color1') != null){
    document.getElementById("speech_text-fg").style.color = getParam('color1');
}

if (getParam('st_color1') != null){
    document.getElementById("speech_text-bg").style.webkitTextStrokeColor = getParam('st_color1');
}

if (getParam('st_width1') != null){
    document.getElementById("speech_text-bg").style.webkitTextStrokeWidth = getParam('st_width1') + 'pt';
}

// Texto de resultado de traducción ----------------
if (getParam('trans_text_font') != null){
    var fontValue = getParam('trans_text_font');
    // Eliminar barras invertidas
    fontValue = fontValue.replace(/\\\\/g, '');
    if (fontValue.toLowerCase() === 'klee') {
        fontValue = 'Klee';
    }
    var fontFamily = '"' + fontValue + '", sans-serif';
    document.getElementById("trans_text").style.fontFamily = fontFamily;
    
    // Aplicar también a elementos hijos
    var bgElement = document.getElementById("trans_text-bg");
    var fgElement = document.getElementById("trans_text-fg");
    var imbElement = document.getElementById("trans_text-imb");
    
    if (bgElement) bgElement.style.fontFamily = fontFamily;
    if (fgElement) fgElement.style.fontFamily = fontFamily;
    if (imbElement) imbElement.style.fontFamily = fontFamily;
}

if (getParam('size2') != null){
    document.getElementById("trans_text").style.fontSize = getParam('size2') + 'pt';
}

if (getParam('weight2') != null){
    document.getElementById("trans_text").style.fontWeight = getParam('weight2');
}

if (getParam('color2') != null){
    document.getElementById("trans_text-fg").style.color = getParam('color2');
}

if (getParam('st_color2') != null){
    document.getElementById("trans_text-bg").style.webkitTextStrokeColor = getParam('st_color2');
}

if (getParam('st_width2') != null){
    document.getElementById("trans_text-bg").style.webkitTextStrokeWidth = getParam('st_width2') + 'pt';
}

// Texto de resultado de traducción (segundo lenguaje) -----------
if (getParam('trans_text2_font') != null){
    var fontValue = getParam('trans_text2_font');
    // Eliminar barras invertidas
    fontValue = fontValue.replace(/\\\\/g, '');
    if (fontValue.toLowerCase() === 'klee') {
        fontValue = 'Klee';
    }
    var fontFamily = '"' + fontValue + '", sans-serif';
    document.getElementById("trans_text2").style.fontFamily = fontFamily;
    
    // Aplicar también a elementos hijos
    var bgElement = document.getElementById("trans_text2-bg");
    var fgElement = document.getElementById("trans_text2-fg");
    var imbElement = document.getElementById("trans_text2-imb");
    
    if (bgElement) bgElement.style.fontFamily = fontFamily;
    if (fgElement) fgElement.style.fontFamily = fontFamily;
    if (imbElement) imbElement.style.fontFamily = fontFamily;
}


if (getParam('size3') != null){
    document.getElementById("trans_text2").style.fontSize = getParam('size3') + 'pt';
}

if (getParam('weight3') != null){
    document.getElementById("trans_text2").style.fontWeight = getParam('weight3');
}

if (getParam('color3') != null){
    document.getElementById("trans_text2-fg").style.color = getParam('color3');
}

if (getParam('st_color3') != null){
    document.getElementById("trans_text2-bg").style.webkitTextStrokeColor = getParam('st_color3');
}

if (getParam('st_width3') != null){
    document.getElementById("trans_text2-bg").style.webkitTextStrokeWidth = getParam('st_width3') + 'pt';
}

// Texto de resultado de traducción (segundo lenguaje) -----------
if (getParam('trans_text3_font') != null){
    var fontValue = getParam('trans_text3_font');
    // Eliminar barras invertidas
    fontValue = fontValue.replace(/\\\\/g, '');
    if (fontValue.toLowerCase() === 'klee') {
        fontValue = 'Klee';
    }
    var fontFamily = '"' + fontValue + '", sans-serif';
    document.getElementById("trans_text3").style.fontFamily = fontFamily;
    
    // Aplicar también a elementos hijos
    var bgElement = document.getElementById("trans_text3-bg");
    var fgElement = document.getElementById("trans_text3-fg");
    var imbElement = document.getElementById("trans_text3-imb");
    
    if (bgElement) bgElement.style.fontFamily = fontFamily;
    if (fgElement) fgElement.style.fontFamily = fontFamily;
    if (imbElement) imbElement.style.fontFamily = fontFamily;
}


if (getParam('size4') != null){
    document.getElementById("trans_text3").style.fontSize = getParam('size4') + 'pt';
}

if (getParam('weight4') != null){
    document.getElementById("trans_text3").style.fontWeight = getParam('weight4');
}

if (getParam('color4') != null){
    document.getElementById("trans_text3-fg").style.color = getParam('color4');
}

if (getParam('st_color4') != null){
    document.getElementById("trans_text3-bg").style.webkitTextStrokeColor = getParam('st_color4');
}

if (getParam('st_width4') != null){
    document.getElementById("trans_text3-bg").style.webkitTextStrokeWidth = getParam('st_width4') + 'pt';
}

// Configuración de interlineado ############################################
if (getParam('line_spacing_1') != null){
    // Entre texto de reconocimiento y texto de traducción 1
    document.getElementById("speech_text").style.marginBottom = getParam('line_spacing_1') + 'px';
}

if (getParam('line_spacing_2') != null){
    // Entre texto de traducción 1 y texto de traducción 2
    document.getElementById("trans_text").style.marginBottom = getParam('line_spacing_2') + 'px';
}

if (getParam('line_spacing_3') != null){
    // Entre texto de traducción 2 y texto de traducción 3
    document.getElementById("trans_text2").style.marginBottom = getParam('line_spacing_3') + 'px';
}

</script>




</html>
